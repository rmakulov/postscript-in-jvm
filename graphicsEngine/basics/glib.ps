%(graphicsEngine/basics/listLib.ps) (r) file run
(graphicsEngine/basics/listLib.ps) (r) file run
%PROLOG
%---
/window <</label (window) /x 0 /y 0 /h 843 /w 651  /parent null /children null /paint {pop} /eventProcs <</RIGHT_CLICK [{pop evX evY wave}[]]>> >> def
%---
/addElement {gelements gelements /maxElementNumber get 3 2 roll put  gelements /maxElementNumber gelements /maxElementNumber get 1 add put } def
%---
/button {
    /eventProcDict exch def
    /parent exch def
    /label exch def
    /h exch def
    /w exch def
    /y exch def
    /x exch def
    /paint {/bd exch def
                bd /x get
                bd /y get
                bd /w get
                bd /h get
                bd /label get

                bd /isPressed get
                {(graphicsEngine/basics/PressedButton.ps) (r) file run}
                    {(graphicsEngine/basics/UnpressedButton.ps) (r) file run}
                ifelse
        } def
        %eventProcs - procedures for each type of events
    /buttonDict <</label label /x x /y y /h h /w w  /parent parent /children null
                        /paint /paint load
                        /eventProcs eventProcDict
                        /isPressed false
    >> def



    buttonDict addElement


    %element - event, действие забирает один элемент со стека - графический элемент. В момент вызова процедуры в checkElement event.ps кладем buttonDict
    buttonDict /eventProcs get /RELEASE { /isPressed false put repaintAll} addListToDict
    buttonDict /eventProcs get /PRESS { /isPressed true put repaintAll} addListToDict


%
    parent /children [buttonDict parent /children get] put
    %x y h w label paint
    buttonDict paint
} def
%---
/checkBox {
    /eventProcDict exch def
    /parent exch def
    /label exch def
    /h exch def
    /y exch def
    /x exch def
    /paint {/bd exch def
                bd /x get
                bd /y get
                bd /h get
                bd /label get
                bd /isPressed get
                {(graphicsEngine/basics/PressedCheckbox.ps) (r) file run}
                    {(graphicsEngine/basics/UnpressedCheckbox.ps) (r) file run}
                ifelse
        } def
        %eventProcs - procedures for each type of events
    /checkboxDict <</label label /x x /y y /w h /h h /parent parent /children null
                        /paint /paint load
                        /eventProcs eventProcDict
                        /isPressed false
    >> def



    checkboxDict addElement

    %element - event, действие забирает один элемент со стека - графический элемент. В момент вызова процедуры в checkElement event.ps кладем checkboxDict
    checkboxDict /eventProcs get /RELEASE {dup /isPressed get /isPressed exch not put repaintAll} addListToDict
    %checkboxDict /eventProcs get /PRESS { dup /isPressed get /isPressed exch not put repaintAll} addListToDict

    parent /children [checkboxDict parent /children get] put
    %x y h w label paint
    checkboxDict paint
} def
%---
/textField {
              /eventProcDict exch def
              /parent exch def
              /label exch def
              /h exch def
              /w exch def
              /y exch def
              /x exch def
              /paint {/bd exch def
                          bd /x get
                          bd /y get
                          bd /w get
                          bd /h get
                          bd /label get
                          bd /text get
                          bd /inFocus get
                          (graphicsEngine/basics/textField.ps) (r) file run
                  } def
                  %eventProcs - procedures for each type of events
              /textFieldDict <</label label /text () /x x /y y /w w /h h /parent parent /children null /inFocus false
                                  /paint /paint load
                                  /eventProcs eventProcDict
              >> def



              textFieldDict addElement

              %element - event, действие забирает один элемент со стека - графический элемент. В момент вызова процедуры в checkElement event.ps кладем checkboxDict
              textFieldDict /eventProcs get /RELEASE { dup /inFocus true put gelements /focusedElement 3 2 roll put repaintAll} addListToDict
              textFieldDict /eventProcs get /KEYBOARD {
                   /char exch def
                   /textField exch def
                   textField dup /text get char concatStrings /text exch put
                   repaintAll
              } addListToDict

              parent /children [textFieldDict parent /children get] put
              textFieldDict paint

} def
%---
/invertString {
    dup
    /len exch length def
    /outStr len string def
    /i len 1 sub def
    {outStr i  3 2 roll put /i i 1 sub def} forall
    outStr
} def
%---
/repaintAll {
      init
      0 1 gelements /maxElementNumber get 1 sub {gelements exch get dup /paint get exec} for
    } def
%---
/invertLabels {
    0 1 gelements /maxElementNumber get 1 sub
    {
        gelements exch get
        dup
            /label get
        invertString
        /label exch put
    } for
} def
%---
/getGelement {
       transform
       /pointY exch def
       /pointX exch def
       gelements /maxElementNumber get 1 sub -1 0 {
                gelements exch get
                /element exch def
                /x element /x get def
                /y element /y get def
                /w element /w get def
                /h element /h get def

                pointX x ge pointY y ge and
                x w add pointX ge y h add pointY ge and
                and
                {element exit}
                if
       } for
} def
%--- param: sleepInterval set sleep duration
/sleep
{
        /snapshot save def
        % Single arg off stack - seconds to sleep
        /sleepInterval exch def
        % Get our starting time
        usertime 1000 idiv /starttime exch def
        {
                % Seconds since start
                usertime 1000 idiv starttime sub
                % Exit if interval is exceeded
                sleepInterval ge { exit } if
        } loop
        snapshot restore
} def
%---
/milliSleep
{
        % Single arg off stack - milliseconds to sleep
        /sleepInterval exch def
        % Get our starting time
        usertime /starttime exch def
        {
                % Seconds since start
                usertime  starttime sub
                % Exit if interval is exceeded
                sleepInterval ge { exit } if
        } loop
} def
%---
% params: x y set center of circles
/wave {
    %   transform
    /y exch def
    /x exch def
    /r 20 def
    /deltaR 10 def
    0.5 setgray

    %debug
     3 {
        x r add y moveto
        x y r 0 360 arc closepath stroke
        500 milliSleep
        %repaintAll
        /r r deltaR add def
        %debug
     } repeat

} def

%---
% param: [a] - array
/toList{
    /arr exch def
    /len arr length
    /res null def
    len 1 sub -1 0 {
        arr exch get
        % a /res [      --->     /res [ a
        /res  [ 3 2 roll res ] def
    } for
} def
%---
%params: dict, key, value
% key associated with list of values
/addListToDict{
    /value exch def
    /key exch def
    /dict exch def
    dict key known
    {        dict key get /value load addToList  }
    {        dict key [/value load  []] put    }
    ifelse
} def

%---
%params : s1, s2 : strings to concatenate
% result : s1+s2
/concatStrings{
    /s2 exch def
    /s1 exch def
    s1 length
    s2 length
    add
    string dup dup 0 s1 putinterval s1 length s2 putinterval

} def
%END_PROLOG

/gelements 1 dict def
gelements /maxElementNumber 0 put
gelements /focusedElement window put
window addElement

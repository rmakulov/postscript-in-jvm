%!PS
%%BoundingBox: 36 126 576 666
/resolution 72 def
/collect{[ 4 1 roll ]}def
/nget{exch dup 3 1 roll exch get}def
/polydup{1 add [ exch 1 roll ] aload aload pop}def
/circle{aload pop newpath 0 360 arc closepath stroke}def
/inverse
     {
     aload 4 1 roll 3 1 roll dup mul exch dup mul add exch dup mul sub
     dup 0 eq not {1 exch div} if
     exch
     aload pop
     4 -1 roll dup 5 1 roll mul 3 1 roll
     4 -1 roll dup 5 1 roll mul 3 1 roll
     4 -1 roll dup 5 1 roll mul 3 1 roll
     4 -1 roll pop
     dup 0 lt {neg} if
     collect
     }
def
/between
     {
     collect
     0 nget 2 get exch 1 nget 2 get exch 3 1 roll
     lt {aload pop 3 1 roll exch 3 -1 roll collect} if
     0 nget 2 get exch 2 nget 2 get exch 3 1 roll
     lt {aload pop 3 -1 roll exch 3 1 roll collect} if
     1 nget 0 get exch 2 nget 2 get exch
     2 nget 0 get exch 1 nget 2 get exch
     1 nget 2 get exch 2 nget 2 get exch
     7 1 roll add 5 1 roll mul 3 1 roll mul add exch div
     /xdisp exch def
     1 nget 1 get exch 2 nget 2 get exch
     2 nget 1 get exch 1 nget 2 get exch
     1 nget 2 get exch 2 nget 2 get exch
     7 1 roll add 5 1 roll mul 3 1 roll mul add exch div
     /ydisp exch def
     0 nget aload pop 3 1 roll ydisp sub 3 1 roll xdisp sub 3 1 roll
collect
     inverse dup
     /first exch def
     /second exch def
     1 nget 1 get exch 2 nget 1 get exch 3 1 roll sub /xvect exch def
     2 nget 0 get exch 1 nget 0 get exch 3 1 roll sub /yvect exch def
     xvect dup mul yvect dup mul add sqrt
     dup 0.0 eq not {first 2 get 2 mul exch div} if
     dup xvect mul /xvect exch def
     yvect mul /yvect exch def
     first aload pop 3 1 roll yvect add 3 1 roll xvect add 3 1 roll
collect
     inverse /first exch def
     second aload pop 3 1 roll yvect sub 3 1 roll xvect sub 3 1 roll
collect
     inverse /second exch def
     first second
     first 2 get second 2 get sub
     0 gt {exch} if
     pop
     aload pop
     3 1 roll ydisp add 3 1 roll xdisp add 3 1 roll collect
     exch pop
     }
def
/appol
     {
     aload pop 3 polydup between
     dup circle
     2 nget small gt
          {
          1 1 3
               {pop 3 polydup collect 5 1 roll 4 -1 roll}
          for
          }
     if
     pop pop pop pop
     }
def
/inside
     {
     /temp exch def
     0 120 240
          {
          /angle exch def
          temp aload pop
          3 sqrt 2 div 1 add div
          /radius exch def
          angle sin radius mul
          angle cos radius mul
          exch 4 -1 roll add
          3 1 roll add
          radius 3 sqrt 2 div mul
          collect
          }
     for
     }
def
/small 72 resolution div def
small setlinewidth
[306 396 270] dup inside 4 polydup
1 1 4
     {pop circle}
for
1 1 4
     {pop 3 polydup collect 5 1 roll 4 1 roll}
for
pop pop pop pop
{count 0 eq {exit} if appol} loop
showpage

